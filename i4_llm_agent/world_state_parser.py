# === START OF FILE i4_llm_agent/world_state_parser.py ===
# i4_llm_agent/world_state_parser.py

import logging
import re
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__) # i4_llm_agent.world_state_parser

# --- Keyword/Regex Patterns (Examples - Needs Expansion) ---

# Patterns for detecting a day increment
DAY_CHANGE_PATTERNS = [
    re.compile(r'\b(next|following)\s+(day|morning)\b', re.IGNORECASE),
    re.compile(r'\b(dawn|sunris|morn)\s+(broke|came|arrived)\b', re.IGNORECASE),
    re.compile(r'\b(day|night)\s+(passed|went by|elapsed)\b', re.IGNORECASE),
    re.compile(r'after\s+(a|the)\s+night', re.IGNORECASE),
    re.compile(r'several\s+days\s+(passed|later)', re.IGNORECASE), # Could increment by more than 1 later
    # Explicit markers (if LLM is prompted to use them)
    re.compile(r'\[\s*Time\s+Skip\s*:\s*Next\s+Day\s*\]', re.IGNORECASE),
    re.compile(r'\[\s*Day\s+(\d+)\s*\]', re.IGNORECASE), # Could potentially parse day number
]

# Patterns for detecting time of day changes
TIME_OF_DAY_PATTERNS = {
    "Morning": [
        re.compile(r'\b(morning|dawn|sunrise)\b', re.IGNORECASE),
        re.compile(r'sun\s+(rose|came up)', re.IGNORECASE),
    ],
    "Afternoon": [
        re.compile(r'\b(afternoon|midday|noon)\b', re.IGNORECASE),
        re.compile(r'sun\s+(high|at its peak)', re.IGNORECASE),
    ],
    "Evening": [
        re.compile(r'\b(evening|dusk|twilight|sundown|sunset)\b', re.IGNORECASE),
        re.compile(r'\b(sun|day)\s+(set|setting|dipped|waned)\b', re.IGNORECASE),
        re.compile(r'towards\s+night', re.IGNORECASE),
    ],
    "Night": [
        re.compile(r'\b(night|nightfall|midnight)\b', re.IGNORECASE),
        re.compile(r'\b(dark|darkness)\s+(fell|came)\b', re.IGNORECASE),
        re.compile(r'\b(moon|stars)\s+(came out|appeared|rose)\b', re.IGNORECASE),
    ]
}

# Patterns for detecting weather changes
WEATHER_PATTERNS = {
    "Clear": [
        re.compile(r'\b(sun|sky)\s+(clear|cleared|bright|shining)\b', re.IGNORECASE),
        re.compile(r'\b(rain|storm|snow)\s+(stopped|ended|passed)\b', re.IGNORECASE),
        re.compile(r'clouds\s+(parted|cleared|dissipated)', re.IGNORECASE),
    ],
    "Cloudy": [
        re.compile(r'\b(cloudy|overcast)\b', re.IGNORECASE),
        re.compile(r'clouds\s+(gathered|rolled in|covered the sky)', re.IGNORECASE),
        re.compile(r'sun\s+(hidden|obscured)', re.IGNORECASE),
    ],
    "Rainy": [ # Simple example, could differentiate light/heavy later
        re.compile(r'\b(rain|raining|drizzle|downpour|storm)\b', re.IGNORECASE),
        re.compile(r'\b(started to rain|began raining)\b', re.IGNORECASE),
    ],
    "Snowy": [
        re.compile(r'\b(snow|snowing|snowfall|blizzard)\b', re.IGNORECASE),
        re.compile(r'\b(started to snow|began snowing)\b', re.IGNORECASE),
    ]
    # Add Foggy, Windy, etc. as needed
}

# Patterns for detecting season changes (Likely less reliable, depends on LLM being explicit)
SEASON_PATTERNS = {
    "Spring": [re.compile(r'\b(spring)\b', re.IGNORECASE), re.compile(r'buds|blooms|thaw', re.IGNORECASE)],
    "Summer": [re.compile(r'\b(summer)\b', re.IGNORECASE), re.compile(r'hot|heat wave', re.IGNORECASE)],
    "Autumn": [re.compile(r'\b(autumn|fall)\b', re.IGNORECASE), re.compile(r'leaves\s+(turn|fall|falling)', re.IGNORECASE)],
    "Winter": [re.compile(r'\b(winter)\b', re.IGNORECASE), re.compile(r'frost|freeze|deep snow|first snow', re.IGNORECASE)],
}

# --- Main Parsing Function ---

def parse_llm_response_for_state_changes(response_text: Optional[str]) -> Dict[str, Any]:
    """
    Analyzes the LLM response text for keywords/patterns indicating world state changes.

    Args:
        response_text: The text generated by the main LLM for the current turn.

    Returns:
        A dictionary containing detected changes. Keys can be:
        - 'day_increment': (int) Number of days passed (usually 1).
        - 'time_of_day': (str) New time of day (e.g., "Morning", "Night").
        - 'weather': (str) New weather state (e.g., "Rainy", "Clear").
        - 'season': (str) New season (e.g., "Winter").
        Returns an empty dictionary if no changes are detected or input is invalid.
    """
    detected_changes: Dict[str, Any] = {}
    if not response_text or not isinstance(response_text, str):
        return detected_changes

    # --- 1. Check for Day Change ---
    # Simple check: if any day change pattern matches, increment by 1.
    # More complex logic could parse day numbers or multi-day skips later.
    # We only detect the *first* match to avoid multiple increments in one response.
    for pattern in DAY_CHANGE_PATTERNS:
        if pattern.search(response_text):
            logger.debug(f"Detected Day Change pattern: {pattern.pattern}")
            detected_changes['day_increment'] = 1
            # If a day changed, assume time resets to Morning unless specified otherwise
            if 'time_of_day' not in detected_changes:
                 detected_changes['time_of_day'] = "Morning"
            break # Stop after first match

    # --- 2. Check for Time of Day Change ---
    # Check last matched time preference (e.g. evening override morning if both appear)
    # This is basic; more sophisticated logic might look at sentence structure.
    last_matched_time = None
    for time_name, patterns in TIME_OF_DAY_PATTERNS.items():
        for pattern in patterns:
            if pattern.search(response_text):
                logger.debug(f"Detected Time Change pattern: {pattern.pattern} -> {time_name}")
                last_matched_time = time_name
                # Don't break here, allow later patterns (e.g., "night") to override earlier ("evening")
    if last_matched_time and detected_changes.get('time_of_day') != last_matched_time:
        detected_changes['time_of_day'] = last_matched_time

    # --- 3. Check for Weather Change ---
    last_matched_weather = None
    for weather_name, patterns in WEATHER_PATTERNS.items():
        for pattern in patterns:
            if pattern.search(response_text):
                logger.debug(f"Detected Weather Change pattern: {pattern.pattern} -> {weather_name}")
                last_matched_weather = weather_name
    if last_matched_weather:
        detected_changes['weather'] = last_matched_weather

    # --- 4. Check for Season Change ---
    last_matched_season = None
    for season_name, patterns in SEASON_PATTERNS.items():
        for pattern in patterns:
            if pattern.search(response_text):
                logger.debug(f"Detected Season Change pattern: {pattern.pattern} -> {season_name}")
                last_matched_season = season_name
    if last_matched_season:
        detected_changes['season'] = last_matched_season

    if detected_changes:
        logger.info(f"World state changes detected in response: {detected_changes}")
    else:
        logger.debug("No world state changes detected in response.")

    return detected_changes

# === END OF FILE i4_llm_agent/world_state_parser.py ===
